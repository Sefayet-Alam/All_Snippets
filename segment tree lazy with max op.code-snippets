{
	"Segment tree lazy with min max": {
  "prefix": "Segment tree lazy with max query",
  "body": [
    "struct segment_tree",
    "{",
    "    int size;",
    "    vector<ll> segment_tree;",
    "    vector<ll> lazy;",
    "",
    "    void push(ll node, ll st, ll ed)",
    "    {",
    "        if (lazy[node] != 0)",
    "        {",
    "            segment_tree[node] = lazy[node];",
    "            if (st != ed)",
    "            {",
    "                lazy[2 * node] = lazy[node];",
    "                lazy[2 * node + 1] = lazy[node];",
    "            }",
    "            lazy[node] = 0;",
    "        }",
    "    }",
    "    void init(ll n, vector<ll> &arr)",
    "    {",
    "        size = n;",
    "        segment_tree.assign(n * 4, 0);",
    "        lazy.assign(4 * n, 0);",
    "        // built(1, 0, n-1, arr);",
    "    }",
    "",
    "    void update(int node, ll st, ll ed, ll l, ll r, ll val)",
    "    {",
    "        push(node, st, ed);",
    "        if (st > r || ed < l)",
    "        {",
    "            return;",
    "        }",
    "        if (st >= l && ed <= r)",
    "        {",
    "            segment_tree[node] = val;",
    "            if (st != ed)",
    "            {",
    "                lazy[2 * node] = val;",
    "                lazy[2 * node + 1] = val;",
    "            }",
    "",
    "            return;",
    "        }",
    "        int mid = (st + ed) / 2;",
    "        update(2 * node, st, mid, l, r, val);",
    "        update(2 * node + 1, mid + 1, ed, l, r, val);",
    "        segment_tree[node] = max(segment_tree[2 * node], segment_tree[2 * node + 1]);",
    "    }",
    "    //basically assigns value when max seg tree ",
    "    void update(int l, int r, int val)",
    "    {",
    "        update(1, 0, size - 1, l, r, val);",
    "    }",
    "",
    "    ll query(ll node, ll st, ll ed, ll l, ll r)",
    "    {",
    "        push(node, st, ed);",
    "        if (st > r || ed < l)",
    "        {",
    "            return 0;",
    "        }",
    "        if (st >= l && ed <= r)",
    "        {",
    "            return segment_tree[node];",
    "        }",
    "",
    "        int mid = (st + ed) / 2;",
    "        ll leftSum = query(2 * node, st, mid, l, r);",
    "        ll rightSum = query(2 * node + 1, mid + 1, ed, l, r);",
    "        return max(leftSum, rightSum);",
    "    }",
    "    ll query(int l, int r)",
    "    {",
    "        return query(1, 0, size - 1, l, r);",
    "    }",
    "    //queries from l to r",
    "};",
    ""
  ],
  "description": "Segment tree lazy with min max"
}
}