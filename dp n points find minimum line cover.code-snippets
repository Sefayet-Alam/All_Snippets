{
	"dp Given n points minimum no of lines that cover them all": {
		"prefix": "dp Given n points minimum no of lines that cover them all",
		"body": [
		  "/// BIT MANIPULATION",
		  "",
		  "#define Set(x, k) (x |= (1LL << k))",
		  "#define Unset(x, k) (x &= ~(1LL << k))",
		  "#define Check(x, k) (x & (1LL << k))",
		  "#define Toggle(x, k) (x ^ (1LL << k))",
		  "",
		  "int popcount(ll x) { return __builtin_popcountll(x); };",
		  "int poplow(ll x) { return __builtin_ctzll(x); };",
		  "int pophigh(ll x) { return 63 - __builtin_clzll(x); };",
		  "",
		  "",
		  "",
		  "ll n;",
		  "vector<pll>vec(N);",
		  "ll dp[(1LL<<17)];",
		  "",
		  "ll connected[17][17];//stores which points are connected with the line i to j",
		  "",
		  "ll func(ll msk){",
		  "    if(dp[msk]!=-1) return dp[msk];",
		  "    if(msk==(1LL<<n)-1){",
		  "        return dp[msk]=0;",
		  "    }",
		  "    ",
		  "    ll cnt = popcount(msk); ",
		  "    if(cnt == n - 1 || cnt == n - 2) return dp[msk] = 1;",
		  "    ll ret=M;",
		  "    for(ll i=0;i<n;i++){",
		  "        if(Check(msk,i)) continue;",
		  "        for(ll j=i+1;j<n;j++){",
		  "            if(Check(msk,i) || Check(msk,j)) continue;",
		  "            ret=min(ret,1+ func(msk|(connected[i][j])));",
		  "        }",
		  "        break;",
		  "    }",
		  "    return dp[msk]=ret;",
		  "}",
		  "",
		  "bool sameline(ll i,ll j,ll k){",
		  "    return (vec[j].second-vec[i].second)*(vec[k].first-vec[i].first)==(vec[k].second-vec[i].second)*(vec[j].first-vec[i].first);",
		  "}",
		  "",
		  "void solve(){",
		  "        mem(connected,0);",
		  "        mem(dp,-1);",
		  "        cin>>n;",
		  "        vec.resize(n);",
		  "        for(ll i=0;i<n;i++){",
		  "            cin>>vec[i].first>>vec[i].second;",
		  "        }",
		  "        for(ll i=0;i<n;i++){",
		  "            for(ll j=i+1;j<n;j++){",
		  "                ll curr=0;",
		  "                for(ll k=0;k<n;k++){",
		  "                    if(sameline(i,j,k)) curr|=(1LL<<k);",
		  "                }",
		  "                connected[i][j]=curr;",
		  "            }",
		  "        }",
		  "       ",
		  "        ll ans=func(0);",
		  "        cout<<ans<<nn;",
		  "}"
		],
		"description": "dp Given n points minimum no of lines that cover them all"
	  }
}