{
	"Longest common substring O(nlogn)": {
  "prefix": "Longest common substring O(nlogn)",
  "body": [
    "/***",
    " *",
    " * 64-bit hashing for vectors or strings",
    " * Get the forward and reverse hash of any segment",
    " * Base is chosen randomly to prevent anti-hash cases from being constructed",
    " *",
    " * Complexity - O(n) to build, O(1) for each hash query",
    " *",
    " ***/",
    "",
    "#define MAXLEN 100005",
    "constexpr uint64_t mod = (1ULL << 61) - 1;",
    "",
    "const uint64_t seed = chrono::system_clock::now().time_since_epoch().count();",
    "const uint64_t base = mt19937_64(seed)() % (mod / 3) + (mod / 3);",
    "",
    "uint64_t base_pow[MAXLEN];",
    "",
    "int64_t modmul(uint64_t a, uint64_t b)",
    "{",
    "    uint64_t l1 = (uint32_t)a, h1 = a >> 32, l2 = (uint32_t)b, h2 = b >> 32;",
    "    uint64_t l = l1 * l2, m = l1 * h2 + l2 * h1, h = h1 * h2;",
    "    uint64_t ret = (l & mod) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;",
    "    ret = (ret & mod) + (ret >> 61);",
    "    ret = (ret & mod) + (ret >> 61);",
    "    return ret - 1;",
    "}",
    "",
    "void init()",
    "{",
    "    base_pow[0] = 1;",
    "    for (int i = 1; i < MAXLEN; i++)",
    "    {",
    "        base_pow[i] = modmul(base_pow[i - 1], base);",
    "    }",
    "}",
    "",
    "struct PolyHash",
    "{",
    "    /// Remove suff vector and usage if reverse hash is not required for more speed",
    "    vector<int64_t> pref;",
    "",
    "    PolyHash() {}",
    "",
    "    template <typename T>",
    "    PolyHash(const vector<T> &ar)",
    "    {",
    "        if (!base_pow[0])",
    "            init();",
    "",
    "        int n = ar.size();",
    "        pref.resize(n + 3, 0);",
    "",
    "        for (int i = 1; i <= n; i++)",
    "        {",
    "            pref[i] = modmul(pref[i - 1], base) + ar[i - 1] + 997;",
    "            if (pref[i] >= mod)",
    "                pref[i] -= mod;",
    "        }",
    "    }",
    "",
    "    PolyHash(const char *str)",
    "        : PolyHash(vector<char>(str, str + strlen(str))) {}",
    "    PolyHash(string str)",
    "        : PolyHash(vector<char>(all(str))) {}",
    "    uint64_t get_hash(int l, int r)",
    "    {",
    "        int64_t h = pref[r + 1] - modmul(base_pow[r - l + 1], pref[l]);",
    "        return h < 0 ? h + mod : h;",
    "    }",
    "};",
    "",
    "// longest common substring of s and p",
    "string solve(string s, string p)",
    "{",
    "    ll n = s.size();",
    "    ll len = 0;",
    "    PolyHash hs1(s), hs2(p);",
    "",
    "    ll anshash = 0;",
    "    // O(n)",
    "    auto func = [&](ll pos) -> bool",
    "    {",
    "        // check for length=pos",
    "        unordered_map<ll, ll> freq;",
    "        for (ll i = 0; i + pos - 1 < n; i++)",
    "        {",
    "            ll k = hs2.get_hash(i, i + pos - 1); // substring p[i,i+1,...,i+pos-1]",
    "            freq[k]++;",
    "            // // checks if some reverse substring of p= some substring of s",
    "            // k = hs2.rev_hash(i, i + pos - 1); // reverse substring p[i,i+1,...,i+pos-1]",
    "            // freq[k]++;",
    "        }",
    "        for (ll i = 0; i + pos - 1 < n; i++)",
    "        {",
    "            ll now = hs1.get_hash(i, i + pos - 1); // substring s[i,i+1,....,i+pos-1]",
    "            if (freq.find(now) != freq.end())",
    "            {",
    "                anshash = now;",
    "                return true;",
    "            }",
    "        }",
    "        return false;",
    "    };",
    "",
    "    ll low = 1;",
    "    ll high = n;",
    "    ll mid;",
    "    // ll anshash = 0",
    "    // logn",
    "    while (low <= high)",
    "    {",
    "        mid = low + (high - low) / 2;",
    "        // cout<<mid<<\" \"<<func(mid)<<endl;",
    "        if (func(mid))",
    "        {",
    "            len = mid;",
    "            low = mid + 1;",
    "        }",
    "        else",
    "        {",
    "            high = mid - 1;",
    "        }",
    "    }",
    "    if (len == 0)",
    "        return \"\";",
    "",
    "    // O(n)",
    "    for (ll i = 0; i + len - 1 < n; i++)",
    "    {",
    "        ll now2 = hs1.get_hash(i, i + len - 1);",
    "        if (now2 == anshash)",
    "        {",
    "            return s.substr(i, len);",
    "        }",
    "    }",
    "}"
  ],
  "description": "Longest common substring O(nlogn)"
}
}